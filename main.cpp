#include <iostream> // Подключаем заголовочный файл для ввода-вывода через стандартные потоки ввода-вывода.
#include <vector> // Подключаем заголовочный файл для работы с контейнером std::vector.
#include <cmath> // Подключаем заголовочный файл для математических функций.
#include <functional> // Подключаем заголовочный файл для использования std::function.

// Функция для поиска минимума на отрезке с помощью метода золотого сечения
double golden_section_search(std::function<double(double)> f, double a, double b, double tol = 0.001) {
    const double gr = (std::sqrt(5) + 1) / 2; // Вычисляем золотое сечение.
    double c = b - (b - a) / gr; // Вычисляем значение c по формуле золотого сечения.
    double d = a + (b - a) / gr; // Вычисляем значение d по формуле золотого сечения.
    while (std::abs(c - d) > tol) { // Повторяем цикл, пока разница между c и d больше заданной точности.
        if (f(c) < f(d)) { // Если значение функции в точке c меньше, чем в точке d...
            b = d; // ...то сдвигаем правую границу отрезка.
        }
        else { // В противном случае...
            a = c; // ...сдвигаем левую границу отрезка.
        }
        c = b - (b - a) / gr; // Пересчитываем c по формуле золотого сечения.
        d = a + (b - a) / gr; // Пересчитываем d по формуле золотого сечения.
    }
    return (b + a) / 2; // Возвращаем середину полученного отрезка как приближенное значение минимума.
}

// Функция для покоординатного спуска с альтернативным направлением
std::vector<double> alternate_coordinate_descent(std::function<double(std::vector<double>)> f, std::vector<double> x0, double tol = 0.001) {
    std::vector<double> x = x0; // Инициализируем вектор x начальным приближением.
    const int n = x.size(); // Получаем размерность пространства.
    int iter_count = 0; // Инициализируем счетчик итераций.
    //double prev_f = f(x); // Вычисляем значение функции в начальной точке.
    while (iter_count<16) { // Бесконечный цикл (до достижения критерия останова).
        std::vector<double> prev_x = x; // Сохраняем предыдущее значение точки.

        // Итерации по координате x
        for (int i = 0; i < n; i += 2) { // Перебираем все координаты x.
            // Функция для минимизации по i-ой переменной
            auto phi = [&](double alpha) { // Лямбда-функция для вычисления значения функции в точке с измененной i-ой координатой.
                std::vector<double> new_x = x; // Создаем копию текущей точки.
                new_x[i] = alpha; // Обновляем i-ую координату в новой точке.
                return f(new_x); // Вычисляем значение функции в новой точке.
                };
            // Используем метод золотого сечения для определения шага
            double alpha_min = golden_section_search(phi, x[i] - 1, x[i] + 1, tol); // Вычисляем минимум функции по i-ой координате методом золотого сечения.
            x[i] = alpha_min; // Обновляем i-ую координату текущей точки.
        }

        // Выводим номер итерации, текущую точку и значение функции
        std::cout << "Итерация " << iter_count + 1 << ": Точка = [";
        for (int i = 0; i < n; ++i) { // Выводим текущую точку.
            std::cout << x[i];
            if (i < n - 1) std::cout << ", ";
        }
        std::cout << "], f(x) = " << f(x) << std::endl; // Выводим значение функции в текущей точке.

        iter_count++; // Увеличиваем счетчик итераций.

        // Проверка на сходимость
       

        // Итерации по координате y
        for (int i = 1; i < n; i += 2) { // Перебираем все координаты y.
            // Функция для минимизации по i-ой переменной
            auto phi = [&](double alpha) { // Лямбда-функция для вычисления значения функции в точке с измененной i-ой координатой.
                std::vector<double> new_x = x; // Создаем копию текущей точки.
                new_x[i] = alpha; // Обновляем i-ую координату в новой точке.
                return f(new_x); // Вычисляем значение функции в новой точке.
                };
            // Используем метод золотого сечения для определения шага
            double alpha_min = golden_section_search(phi, x[i] - 1, x[i] + 1, tol); // Вычисляем минимум функции по i-ой координате методом золотого сечения.
            x[i] = alpha_min; // Обновляем i-ую координату текущей точки.
        }

        // Выводим номер итерации, текущую точку и значение функции
        std::cout << "Итерация " << iter_count + 1 << ": Точка = [";
        for (int i = 0; i < n; ++i) { // Выводим текущую точку.
            std::cout << x[i];
            if (i < n - 1) std::cout << ", ";
        }
        std::cout << "], f(x) = " << f(x) << std::endl; // Выводим значение функции в текущей точке.

        iter_count++; // Увеличиваем счетчик итераций.

        // Проверка на сходимость
        
    }
    return x; // Возвращаем точку минимума.
}


// Пример использования:
double example_function(std::vector<double> x) { // Пример функции для минимизации.
    return 2 * x[0] * x[0] + 4 * x[0] * x[1] + 8 * x[1] * x[1] + 100; // Функция от двух переменных.
}

int main() {
    setlocale(LC_ALL, "Russian");
    std::vector<double> initial_guess = { -10, 10 }; // Начальное приближение.
    std::vector<double> minimum_point = alternate_coordinate_descent(example_function, initial_guess); // Вызов метода покоординатного спуска.
    std::cout << "Точка минимума: ["; // Выводим сообщение о найденной точке минимума.
    for (int i = 0; i < minimum_point.size(); ++i) { // Выводим координаты точки минимума.
        std::cout << minimum_point[i];
        if (i < minimum_point.size() - 1) std::cout << ", ";
    }
    std::cout << "]" << std::endl; // Завершаем вывод координат.
    std::cout << "Значение функции в минимуме: " << example_function(minimum_point) << std::endl; // Выводим значение функции в найденной точке минимума.
    return 0; // Возвращаем 0, чтобы показать успешное завершение программы.
}
